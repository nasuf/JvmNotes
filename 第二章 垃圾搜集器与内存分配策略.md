# 第二章 垃圾搜集器与内存分配策略

## 2.1 算法分类

### 2.1.1 引用计数算法

占用了一些额外的内存空间来进行计数，但是原理简单，判断效率高，大多数情况下都是一个不错的算法。但是在Java领域，至少主流的虚拟机没有选用引用计数算法进行内存管理，因为有很多例外情况要考虑，比如对象之间循环引用问题。

### 2.1.2 可达性分析算法

该算法基本思路是通过一系列成为“GC Roots”的根对象作为起始节点集，从这些节点开始根据引用关系向下搜索，搜索过程走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，证明此对象不可能再被使用。

固定作为GC Roots的对象包括：

+ 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。
+ 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。
+ 在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。
+ 在本地方法栈中JNI（即通常所说的Native方法）引用的对象
+ Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointerException、OutOfMemoryError）等，还有系统类加载器。
+ 所有被同步锁（synchronized关键字）持有的对象。
+ 反应Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。

### 2.1.3 再谈引用

JDK1.2之后，Java将引用分为**强引用（Strongly Reference）、软引用（Soft Reference）、弱引用（Week Reference）、虚引用（Phantom Reference)，引用强度依次递减。

+ 强引用

  如 Object obj = new Object()这种普遍存在的引用赋值；无论任何情况下，只要强引用关系还在，垃圾收集器永远不会回收掉被引用的对象。

+ 软引用（SoftRefrence类实现）

  描述一些还有用但必须的对象；在系统将要发生内存溢出异常前，会把这些对象列进回收范围内进行第二次回收，如果这次回收还没有足够的空间，才会抛出内存异常。

+ 弱引用（WeakReference类实现）

  被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，他们都会被回收掉。

+ 虚引用（PhantomReference类实现）

  为一个对象设置虚引用关联的唯一目的是在这个对象被收集器回收时收到一个系统通知。虚引用的存在不会对对象的生存时间构成影响，也无法通过虚引用来取得一个对象实例。